import React, { useEffect, useMemo, useRef, useState } from "react";
import maplibregl from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";
import proj4 from "proj4";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Info, RefreshCcw, Download, HelpCircle } from "lucide-react";
import { motion } from "framer-motion";

/**
 * IMD 2025 – Re‑weightable Domain Map (Schema‑agnostic build)
 *
 * This version adapts to YOUR existing files. No field renaming or reprojection needed.
 * It will:
 *  - Auto‑detect area code & name fields from common LSOA/MSOA schemas (or fall back to feature.id)
 *  - Auto‑reproject EPSG:27700 (British National Grid) -> WGS84 on the fly using proj4
 *  - Accept File 9 as JSON OR CSV and auto‑detect domain column names by regex
 *  - Join by the detected area code field; render and export bespoke scores/deciles
 */

// ---- Domain detection rules -------------------------------------------------
const DOMAIN_ALIASES: Record<string, RegExp> = {
  dom_income: /income/i,
  dom_employment: /employ/i,
  dom_education: /educ/i,
  dom_health: /health/i,
  dom_crime: /crime/i,
  dom_barriers: /(barrier|housing|access)/i,
  dom_living: /(living|environment)/i,
};

type DomainKey = keyof typeof DOMAIN_ALIASES;

// Default (official‑like) weights – these are normalised later anyway
const DEFAULT_WEIGHTS: Record<DomainKey, number> = {
  dom_income: 22.5,
  dom_employment: 22.5,
  dom_education: 13.5,
  dom_health: 13.5,
  dom_crime: 9.3,
  dom_barriers: 9.3,
  dom_living: 9.3,
};

// Colour palette (NHE look)
const PALETTE = [
  "#0b1b2b","#12324c","#1b4a71","#246198","#2e78bf",
  "#5a94cf","#86b0df","#b3ceee","#d8e5f7","#fff4d6"
];

// ---- Helpers: schema & CRS --------------------------------------------------
function detectCodeKey(props: any): string | null {
  if (!props) return null;
  const candidates = Object.keys(props);
  const patterns = [
    /areacd/i, /(lsoa|msoa).{0,4}cd/i, /code$/i, /^code$/i, /^cd$/i, /(oa).{0,4}cd/i,
  ];
  for (const p of patterns) {
    const hit = candidates.find((k) => p.test(k));
    if (hit) return hit;
  }
  return null;
}

function detectNameKey(props: any): string | null {
  if (!props) return null;
  const candidates = Object.keys(props);
  const patterns = [
    /areanm/i, /(lsoa|msoa).{0,4}nm/i, /(name|label|nm)$/i,
  ];
  for (const p of patterns) {
    const hit = candidates.find((k) => p.test(k));
    if (hit) return hit;
  }
  return null;
}

// EPSG:27700 -> WGS84
proj4.defs("EPSG:27700", "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,125.157,542.06,0.1502,0.2470,0.8421,-20.4894 +units=m +no_defs");

function looksLike27700(feature: any): boolean {
  try {
    const coords = feature?.geometry?.coordinates;
    const sample = Array.isArray(coords) ? (feature.geometry.type === "Polygon" ? coords[0][0] : feature.geometry.type === "MultiPolygon" ? coords[0][0][0] : coords[0]) : null;
    if (!sample) return false;
    const [x, y] = sample;
    return Math.abs(x) > 180 || Math.abs(y) > 90; // rough check for projected metres
  } catch { return false; }
}

function reproject27700to4326(gj: any): any {
  const convert = (pt: [number, number]) => proj4("EPSG:27700", "WGS84", pt);
  const mapCoords = (coords: any, type: string): any => {
    if (type === "Point") return convert(coords);
    if (type === "MultiPoint" || type === "LineString") return coords.map(convert);
    if (type === "MultiLineString" || type === "Polygon") return coords.map((c: any) => c.map(convert));
    if (type === "MultiPolygon") return coords.map((p: any) => p.map((r: any) => r.map(convert)));
    return coords;
  };
  return {
    ...gj,
    crs: { type: "name", properties: { name: "EPSG:4326" } },
    features: gj.features.map((f: any) => ({
      ...f,
      geometry: { ...f.geometry, coordinates: mapCoords(f.geometry.coordinates, f.geometry.type) },
    })),
  };
}

// ---- Data loading (robust to CSV or JSON) ----------------------------------
async function fetchMaybeCSV(url: string): Promise<any[]> {
  const txt = await fetch(url).then((r) => r.text());
  try { return JSON.parse(txt); } catch (_) { /* fall through */ }
  // naive CSV parser (expects commas and optional quotes)
  const lines = txt.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return [];
  const headers = lines[0].split(",").map((h) => h.replace(/^\uFEFF/, "").trim());
  const rows: any[] = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = [] as string[];
    let cur = ""; let inQ = false;
    const s = lines[i];
    for (let j = 0; j < s.length; j++) {
      const ch = s[j];
      if (ch === '"') { inQ = !inQ; }
      else if (ch === "," && !inQ) { cols.push(cur); cur = ""; }
      else { cur += ch; }
    }
    cols.push(cur);
    const obj: any = {};
    headers.forEach((h, k) => obj[h] = (cols[k] ?? "").replace(/^"|"$/g, ""));
    rows.push(obj);
  }
  return rows;
}

function buildDomainKeyMap(sample: any): Record<DomainKey, string> {
  const map: any = {};
  const keys = Object.keys(sample || {});
  (Object.keys(DOMAIN_ALIASES) as DomainKey[]).forEach((dk) => {
    const hit = keys.find((k) => DOMAIN_ALIASES[dk].test(k));
    if (!hit) throw new Error(`Cannot find column for ${dk}`);
    map[dk] = hit;
  });
  return map as Record<DomainKey, string>;
}

function normalizeWeights(w: Record<DomainKey, number>): Record<DomainKey, number> {
  const sum = (Object.values(w).reduce((a, b) => a + (b || 0), 0)) || 1;
  const out: any = {};
  (Object.keys(w) as DomainKey[]).forEach((k) => out[k] = (w[k] || 0) / sum);
  return out;
}

function weightedScore(row: any, normW: Record<DomainKey, number>, dkMap: Record<DomainKey, string>) {
  let s = 0; (Object.keys(dkMap) as DomainKey[]).forEach((k) => { s += Number(row[dkMap[k]]) * normW[k]; });
  return s;
}

function rankAndDeciles(values: number[]) {
  const idx = values.map((v, i) => ({ i, v })).sort((a, b) => b.v - a.v);
  const ranks = Array(values.length).fill(0);
  idx.forEach((o, p) => ranks[o.i] = p + 1);
  const n = values.length, dec = Array(n).fill(0);
  idx.forEach((o, p) => dec[o.i] = Math.min(10, Math.max(1, Math.ceil(((p + 1) / n) * 10))));
  return { ranks, deciles: dec };
}

function toCSV(rows: any[]): string {
  if (!rows.length) return "";
  const cols = Object.keys(rows[0]);
  const esc = (s: any) => `"${String(s).replaceAll('"', '""')}"`;
  return [cols.map(esc).join(","), ...rows.map((r) => cols.map((c) => esc(r[c])).join(","))].join("\n");
}

export default function IMDReweightableMap() {
  const mapRef = useRef<maplibregl.Map | null>(null);
  const mapEl = useRef<HTMLDivElement | null>(null);

  const [areas, setAreas] = useState<any | null>(null); // GeoJSON (auto‑reprojected if needed)
  const [file9, setFile9] = useState<any[] | null>(null); // JSON or CSV parsed rows
  const [codeKey, setCodeKey] = useState<string | null>(null);
  const [nameKey, setNameKey] = useState<string | null>(null);
  const [dkMap, setDkMap] = useState<Record<DomainKey, string> | null>(null);

  const [weights, setWeights] = useState<Record<DomainKey, number>>({ ...DEFAULT_WEIGHTS });
  const [preset, setPreset] = useState<string>("official");
  const [selected, setSelected] = useState<string | null>(null);
  const [showLabels, setShowLabels] = useState(true);

  // Load data exactly as‑is from your files
  useEffect(() => {
    (async () => {
      const rawGJ = await fetch("/data/areas.geojson").then((r) => r.json());
      const gj = looksLike27700(rawGJ.features?.[0]) ? reproject27700to4326(rawGJ) : rawGJ;
      setAreas(gj);

      const f9rows = await fetchMaybeCSV("/data/file9"); // accepts .json OR .csv (omit ext to allow either)
      setFile9(f9rows);

      // detect keys from samples
      const firstFt = gj.features?.[0];
      const props = firstFt?.properties || {};
      setCodeKey(detectCodeKey(props) || null);
      setNameKey(detectNameKey(props) || null);
      if (f9rows?.length) setDkMap(buildDomainKeyMap(f9rows[0]));
    })();
  }, []);

  // Safety: if codeKey missing, fall back to feature.id
  const areasWithKeys = useMemo(() => {
    if (!areas) return null;
    const hasProps = !!(areas.features?.[0]?.properties);
    if (hasProps && codeKey) return areas;
    // add surrogate AREACD from id
    const fc = { ...areas, features: areas.features.map((f: any) => ({
      ...f,
      properties: { ...(f.properties || {}), AREACD: String(f.id ?? "") },
    })) };
    if (!codeKey) setCodeKey("AREACD");
    return fc;
  }, [areas, codeKey]);

  // Build lookups
  const f9ByCode = useMemo(() => {
    const m = new Map<string, any>();
    if (!file9 || !dkMap) return m;
    // find a likely area code column in File 9 (AREACD, LSOA/MSOA code etc.)
    const codeCol = Object.keys(file9[0]).find((k) => /(code|cd|areacd|lsoa|msoa)/i.test(k));
    if (!codeCol) return m;
    file9.forEach((r) => m.set(String(r[codeCol]).trim(), r));
    return m;
  }, [file9, dkMap]);

  const baseline = useMemo(() => {
    if (!file9 || !dkMap) return null;
    const norm = normalizeWeights(DEFAULT_WEIGHTS);
    const scores = file9.map((r) => weightedScore(r, norm, dkMap));
    const { ranks, deciles } = rankAndDeciles(scores);
    return { scores, ranks, deciles };
  }, [file9, dkMap]);

  const bespoke = useMemo(() => {
    if (!file9 || !dkMap) return null;
    const norm = normalizeWeights(weights);
    const scores = file9.map((r) => weightedScore(r, norm, dkMap));
    const { ranks, deciles } = rankAndDeciles(scores);
    return { scores, ranks, deciles, norm };
  }, [file9, dkMap, weights]);

  // Join results to features
  const choropleth = useMemo(() => {
    if (!areasWithKeys || !file9 || !bespoke || !f9ByCode || !codeKey) return null;
    const features = areasWithKeys.features.map((ft: any) => {
      const code = String(ft.properties?.[codeKey] ?? "").trim();
      const row = f9ByCode.get(code);
      const i = row ? file9.indexOf(row) : -1;
      return {
        ...ft,
        properties: {
          ...ft.properties,
          _score: i >= 0 ? bespoke.scores[i] : null,
          _rank: i >= 0 ? bespoke.ranks[i] : null,
          _decile: i >= 0 ? bespoke.deciles[i] : null,
          _baseRank: i >= 0 && baseline ? baseline.ranks[i] : null,
        },
      };
    });
    return { type: "FeatureCollection", features } as any;
  }, [areasWithKeys, file9, bespoke, baseline, f9ByCode, codeKey]);

  // Map setup
  useEffect(() => {
    if (!mapEl.current || mapRef.current) return;
    const map = new maplibregl.Map({
      container: mapEl.current,
      style: "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",
      center: [-2.5, 53.9], zoom: 5.4, attributionControl: true,
    });
    map.addControl(new maplibregl.NavigationControl({ showCompass: false }), "top-right");
    mapRef.current = map;
  }, []);

  // Layer add/update
  useEffect(() => {
    const map = mapRef.current; if (!map || !choropleth) return;
    const srcId = "areas-src", fillId = "areas-fill", lineId = "areas-line";
    if (map.getSource(srcId)) { (map.getSource(srcId) as any).setData(choropleth); }
    else {
      map.addSource(srcId, { type: "geojson", data: choropleth });
      map.addLayer({ id: fillId, type: "fill", source: srcId, paint: {
        "fill-color": [
          "case", ["!has", "_decile"], "#cccccc",
          ["match", ["get", "_decile"],
            1, PALETTE[0],2,PALETTE[1],3,PALETTE[2],4,PALETTE[3],5,PALETTE[4],
            6,PALETTE[5],7,PALETTE[6],8,PALETTE[7],9,PALETTE[8],10,PALETTE[9], "#cccccc"]
        ],
        "fill-opacity": 0.9,
      }});
      map.addLayer({ id: lineId, type: "line", source: srcId, paint: { "line-color": "#fff", "line-width": 0.2, "line-opacity": 0.6 }});
      map.on("click", fillId, (e: any) => { const f = e.features?.[0]; const cd = f?.properties?.[codeKey!]; if (cd) setSelected(String(cd)); });
      map.on("mousemove", fillId, () => map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", fillId, () => map.getCanvas().style.cursor = "");
    }
  }, [choropleth, codeKey]);

  // Selection detail
  const selectedDetail = useMemo(() => {
    if (!selected || !file9 || !bespoke || !baseline || !f9ByCode) return null;
    const row = f9ByCode.get(String(selected)); if (!row) return null;
    const i = file9.indexOf(row);
    const score = bespoke.scores[i], rank = bespoke.ranks[i], dec = bespoke.deciles[i];
    const baseRank = baseline.ranks[i];
    const delta = rank - baseRank;
    return { row, score, rank, dec, baseRank, delta };
  }, [selected, file9, bespoke, baseline, f9ByCode]);

  // Exports
  function handleExportCSV() {
    if (!file9 || !bespoke || !areasWithKeys || !codeKey) return;
    const rows = file9.map((r, i) => ({
      AREACD: [...f9ByCode.entries()].find(([,v]) => v === r)?.[0] ?? "",
      score: bespoke.scores[i], rank: bespoke.ranks[i], decile: bespoke.deciles[i],
    }));
    const csv = toCSV(rows);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob); const a = document.createElement("a");
    a.href = url; a.download = `imd_bespoke_${new Date().toISOString().slice(0,10)}.csv`; a.click(); URL.revokeObjectURL(url);
  }

  function handleExportGeoJSON() {
    if (!choropleth) return;
    const payload = JSON.stringify(choropleth);
    const blob = new Blob([payload], { type: "application/geo+json" });
    const url = URL.createObjectURL(blob); const a = document.createElement("a");
    a.href = url; a.download = `imd_bespoke_${new Date().toISOString().slice(0,10)}.geojson`; a.click(); URL.revokeObjectURL(url);
  }

  // Presets
  const presets: Record<string, { name: string; weights: Record<DomainKey, number> }> = {
    official: { name: "Official IMD (default)", weights: DEFAULT_WEIGHTS },
    healthLed: { name: "Health‑led", weights: { ...DEFAULT_WEIGHTS, dom_health: DEFAULT_WEIGHTS.dom_health * 1.8 } },
    housingLed: { name: "Housing/Access‑led", weights: { ...DEFAULT_WEIGHTS, dom_barriers: DEFAULT_WEIGHTS.dom_barriers * 1.8 } },
    crimeLight: { name: "Crime‑light", weights: { ...DEFAULT_WEIGHTS, dom_crime: DEFAULT_WEIGHTS.dom_crime * 0.5 } },
  };

  const normW = normalizeWeights(weights);

  return (
    <div className="w-full h-[calc(100vh-2rem)] grid grid-cols-1 lg:grid-cols-12 gap-4 p-4 bg-[#0b1b2b] text-white">
      <Card className="lg:col-span-3 bg-[#0f2236] text-white border-0 shadow-xl">
        <CardHeader>
          <CardTitle className="text-xl">IMD 2025 – Bespoke Composite</CardTitle>
          <p className="text-sm opacity-80 flex items-center gap-2"><Info size={16}/> Works with your existing files. We auto‑detect fields & CRS.</p>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <label className="text-sm opacity-90">Preset</label>
            <Select value={preset} onValueChange={(v) => { setPreset(v); setWeights(presets[v].weights); }}>
              <SelectTrigger className="bg-[#102a44] border-0 text-white"><SelectValue /></SelectTrigger>
              <SelectContent className="bg-[#102a44] text-white border-0">
                {Object.entries(presets).map(([k, p]) => (<SelectItem key={k} value={k}>{p.name}</SelectItem>))}
              </SelectContent>
            </Select>
          </div>

          <div className="grid grid-cols-1 gap-4">
            {Object.entries(DOMAIN_ALIASES).map(([dk, _]) => (
              <div key={dk} className="p-3 rounded-2xl bg-[#102a44]">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm font-medium">{dk.replace("dom_", "").replace(/\b\w/g,(m)=>m.toUpperCase())}</span>
                  <span className="text-xs opacity-75">{(normW[dk as DomainKey] * 100).toFixed(1)}%</span>
                </div>
                <Slider value={[weights[dk as DomainKey]]} min={0} max={40} step={0.1}
                  onValueChange={(vals) => setWeights((w) => ({ ...w, [dk as DomainKey]: vals[0] }))} />
              </div>
            ))}
          </div>

          <div className="flex gap-2">
            <Button variant="secondary" className="bg-[#1b4a71] text-white hover:bg-[#246198]" onClick={() => setWeights({ ...DEFAULT_WEIGHTS })}>
              <RefreshCcw className="mr-2 h-4 w-4"/> Reset
            </Button>
            <Button variant="outline" className="border-[#b3ceee] text-[#b3ceee] hover:bg-[#12324c]" onClick={handleExportCSV}>
              <Download className="mr-2 h-4 w-4"/> CSV
            </Button>
            <Button variant="outline" className="border-[#b3ceee] text-[#b3ceee] hover:bg-[#12324c]" onClick={handleExportGeoJSON}>
              <Download className="mr-2 h-4 w-4"/> GeoJSON
            </Button>
          </div>

          <div className="flex items-center justify-between pt-2 border-t border-white/10">
            <label className="text-sm opacity-90 flex items-center gap-2"><HelpCircle size={14}/> Labels</label>
            <Switch checked={showLabels} onCheckedChange={setShowLabels} />
          </div>
        </CardContent>
      </Card>

      <div className="lg:col-span-9 relative rounded-2xl overflow-hidden shadow-2xl">
        <div ref={mapEl} className="w-full h-full" />

        <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }}
          className="absolute bottom-4 left-4 bg-white/90 text-black rounded-xl p-3 shadow-xl">
          <div className="text-xs font-semibold mb-2">Deciles (1 = most deprived)</div>
          <div className="flex items-center gap-1">{PALETTE.map((c, i) => (<div key={i} className="w-6 h-3 rounded" style={{ background: c }} />))}</div>
          <div className="flex justify-between text-[10px] mt-1"><span>1</span><span>10</span></div>
        </motion.div>

        {selectedDetail && (
          <motion.div initial={{ x: 400, opacity: 0 }} animate={{ x: 0, opacity: 1 }}
            className="absolute top-4 right-4 w-80 bg-white text-black rounded-2xl shadow-2xl overflow-hidden">
            <div className="p-4 border-b">
              <div className="text-sm font-semibold">{String(selected)}</div>
              <div className="text-xs opacity-70">Custom composite vs baseline</div>
            </div>
            <div className="p-4 space-y-2 text-sm">
              <div className="flex justify-between"><span>Rank (1=most dep.)</span><span>{selectedDetail.rank}</span></div>
              <div className="flex justify-between"><span>Decile</span><span>{selectedDetail.dec}</span></div>
              <div className="flex justify-between"><span>Baseline rank</span><span>{selectedDetail.baseRank}</span></div>
              <div className="flex justify-between"><span>Δ rank vs baseline</span><span>{selectedDetail.delta > 0 ? `+${selectedDetail.delta}` : selectedDetail.delta}</span></div>
              <div className="p-2 mt-2 border-t text-[10px] opacity-70">
                Not the official IMD. Computed from 2025 transformed domain scores (File 9) with user‑defined weights (normalised).
              </div>
            </div>
          </motion.div>
        )}
      </div>
    </div>
  );
}
